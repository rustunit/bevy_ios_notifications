// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Data.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct BevyIos_Notifications_NotificationId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var identifier: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BevyIos_Notifications_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var calls: BevyIos_Notifications_Request.OneOf_Calls? = nil

  var permissions: BevyIos_Notifications_Request.Permissions {
    get {
      if case .permissions(let v)? = calls {return v}
      return BevyIos_Notifications_Request.Permissions()
    }
    set {calls = .permissions(newValue)}
  }

  var schedule: BevyIos_Notifications_Request.Schedule {
    get {
      if case .schedule(let v)? = calls {return v}
      return BevyIos_Notifications_Request.Schedule()
    }
    set {calls = .schedule(newValue)}
  }

  var pending: BevyIos_Notifications_Request.Pending {
    get {
      if case .pending(let v)? = calls {return v}
      return BevyIos_Notifications_Request.Pending()
    }
    set {calls = .pending(newValue)}
  }

  var removePending: BevyIos_Notifications_Request.RemovePending {
    get {
      if case .removePending(let v)? = calls {return v}
      return BevyIos_Notifications_Request.RemovePending()
    }
    set {calls = .removePending(newValue)}
  }

  var removeDelivered: BevyIos_Notifications_Request.RemoveDelivered {
    get {
      if case .removeDelivered(let v)? = calls {return v}
      return BevyIos_Notifications_Request.RemoveDelivered()
    }
    set {calls = .removeDelivered(newValue)}
  }

  var removeAllPending: BevyIos_Notifications_Request.RemoveAllPending {
    get {
      if case .removeAllPending(let v)? = calls {return v}
      return BevyIos_Notifications_Request.RemoveAllPending()
    }
    set {calls = .removeAllPending(newValue)}
  }

  var removeAllDelivered: BevyIos_Notifications_Request.RemoveAllDelivered {
    get {
      if case .removeAllDelivered(let v)? = calls {return v}
      return BevyIos_Notifications_Request.RemoveAllDelivered()
    }
    set {calls = .removeAllDelivered(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Calls: Equatable {
    case permissions(BevyIos_Notifications_Request.Permissions)
    case schedule(BevyIos_Notifications_Request.Schedule)
    case pending(BevyIos_Notifications_Request.Pending)
    case removePending(BevyIos_Notifications_Request.RemovePending)
    case removeDelivered(BevyIos_Notifications_Request.RemoveDelivered)
    case removeAllPending(BevyIos_Notifications_Request.RemoveAllPending)
    case removeAllDelivered(BevyIos_Notifications_Request.RemoveAllDelivered)

  #if !swift(>=4.1)
    static func ==(lhs: BevyIos_Notifications_Request.OneOf_Calls, rhs: BevyIos_Notifications_Request.OneOf_Calls) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.permissions, .permissions): return {
        guard case .permissions(let l) = lhs, case .permissions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.schedule, .schedule): return {
        guard case .schedule(let l) = lhs, case .schedule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pending, .pending): return {
        guard case .pending(let l) = lhs, case .pending(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removePending, .removePending): return {
        guard case .removePending(let l) = lhs, case .removePending(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removeDelivered, .removeDelivered): return {
        guard case .removeDelivered(let l) = lhs, case .removeDelivered(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removeAllPending, .removeAllPending): return {
        guard case .removeAllPending(let l) = lhs, case .removeAllPending(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removeAllDelivered, .removeAllDelivered): return {
        guard case .removeAllDelivered(let l) = lhs, case .removeAllDelivered(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct Schedule {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var title: String = String()

    var body: String = String()

    var categoryIdentifier: String = String()

    var subtitle: String = String()

    var relevanceScore: Double = 0

    var threadIdentifier: String = String()

    var filterCriteria: String {
      get {return _filterCriteria ?? String()}
      set {_filterCriteria = newValue}
    }
    /// Returns true if `filterCriteria` has been explicitly set.
    var hasFilterCriteria: Bool {return self._filterCriteria != nil}
    /// Clears the value of `filterCriteria`. Subsequent reads from it will return its default value.
    mutating func clearFilterCriteria() {self._filterCriteria = nil}

    var userData: BevyIos_Notifications_UserData {
      get {return _userData ?? BevyIos_Notifications_UserData()}
      set {_userData = newValue}
    }
    /// Returns true if `userData` has been explicitly set.
    var hasUserData: Bool {return self._userData != nil}
    /// Clears the value of `userData`. Subsequent reads from it will return its default value.
    mutating func clearUserData() {self._userData = nil}

    var identifier: String {
      get {return _identifier ?? String()}
      set {_identifier = newValue}
    }
    /// Returns true if `identifier` has been explicitly set.
    var hasIdentifier: Bool {return self._identifier != nil}
    /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
    mutating func clearIdentifier() {self._identifier = nil}

    var badge: Int32 {
      get {return _badge ?? 0}
      set {_badge = newValue}
    }
    /// Returns true if `badge` has been explicitly set.
    var hasBadge: Bool {return self._badge != nil}
    /// Clears the value of `badge`. Subsequent reads from it will return its default value.
    mutating func clearBadge() {self._badge = nil}

    var trigger: BevyIos_Notifications_Request.Schedule.Trigger {
      get {return _trigger ?? BevyIos_Notifications_Request.Schedule.Trigger()}
      set {_trigger = newValue}
    }
    /// Returns true if `trigger` has been explicitly set.
    var hasTrigger: Bool {return self._trigger != nil}
    /// Clears the value of `trigger`. Subsequent reads from it will return its default value.
    mutating func clearTrigger() {self._trigger = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Trigger {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var `repeat`: Bool = false

      var seconds: Double = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _filterCriteria: String? = nil
    fileprivate var _userData: BevyIos_Notifications_UserData? = nil
    fileprivate var _identifier: String? = nil
    fileprivate var _badge: Int32? = nil
    fileprivate var _trigger: BevyIos_Notifications_Request.Schedule.Trigger? = nil
  }

  struct Pending {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RemoveAllPending {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RemoveAllDelivered {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RemovePending {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var items: [BevyIos_Notifications_NotificationId] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RemoveDelivered {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var items: [BevyIos_Notifications_NotificationId] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Permissions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var alert: Bool = false

    var sound: Bool = false

    var badge: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct BevyIos_Notifications_UserData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BevyIos_Notifications_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var calls: BevyIos_Notifications_Response.OneOf_Calls? = nil

  var schedule: BevyIos_Notifications_Response.Schedule {
    get {
      if case .schedule(let v)? = calls {return v}
      return BevyIos_Notifications_Response.Schedule()
    }
    set {calls = .schedule(newValue)}
  }

  var pending: BevyIos_Notifications_Response.Pending {
    get {
      if case .pending(let v)? = calls {return v}
      return BevyIos_Notifications_Response.Pending()
    }
    set {calls = .pending(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Calls: Equatable {
    case schedule(BevyIos_Notifications_Response.Schedule)
    case pending(BevyIos_Notifications_Response.Pending)

  #if !swift(>=4.1)
    static func ==(lhs: BevyIos_Notifications_Response.OneOf_Calls, rhs: BevyIos_Notifications_Response.OneOf_Calls) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.schedule, .schedule): return {
        guard case .schedule(let l) = lhs, case .schedule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pending, .pending): return {
        guard case .pending(let l) = lhs, case .pending(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct Schedule {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identifier: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Pending {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct BevyIos_Notifications_AsyncEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var calls: BevyIos_Notifications_AsyncEvent.OneOf_Calls? = nil

  var permission: BevyIos_Notifications_AsyncEvent.Permission {
    get {
      if case .permission(let v)? = calls {return v}
      return BevyIos_Notifications_AsyncEvent.Permission()
    }
    set {calls = .permission(newValue)}
  }

  var scheduled: BevyIos_Notifications_AsyncEvent.Scheduled {
    get {
      if case .scheduled(let v)? = calls {return v}
      return BevyIos_Notifications_AsyncEvent.Scheduled()
    }
    set {calls = .scheduled(newValue)}
  }

  var pending: BevyIos_Notifications_AsyncEvent.Pending {
    get {
      if case .pending(let v)? = calls {return v}
      return BevyIos_Notifications_AsyncEvent.Pending()
    }
    set {calls = .pending(newValue)}
  }

  var triggeredWhileRunning: BevyIos_Notifications_AsyncEvent.NotificationWhileRunning {
    get {
      if case .triggeredWhileRunning(let v)? = calls {return v}
      return BevyIos_Notifications_AsyncEvent.NotificationWhileRunning()
    }
    set {calls = .triggeredWhileRunning(newValue)}
  }

  var notificationResponse: BevyIos_Notifications_AsyncEvent.NotificationResponse {
    get {
      if case .notificationResponse(let v)? = calls {return v}
      return BevyIos_Notifications_AsyncEvent.NotificationResponse()
    }
    set {calls = .notificationResponse(newValue)}
  }

  var remoteNotificationRegistration: BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration {
    get {
      if case .remoteNotificationRegistration(let v)? = calls {return v}
      return BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration()
    }
    set {calls = .remoteNotificationRegistration(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Calls: Equatable {
    case permission(BevyIos_Notifications_AsyncEvent.Permission)
    case scheduled(BevyIos_Notifications_AsyncEvent.Scheduled)
    case pending(BevyIos_Notifications_AsyncEvent.Pending)
    case triggeredWhileRunning(BevyIos_Notifications_AsyncEvent.NotificationWhileRunning)
    case notificationResponse(BevyIos_Notifications_AsyncEvent.NotificationResponse)
    case remoteNotificationRegistration(BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration)

  #if !swift(>=4.1)
    static func ==(lhs: BevyIos_Notifications_AsyncEvent.OneOf_Calls, rhs: BevyIos_Notifications_AsyncEvent.OneOf_Calls) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.permission, .permission): return {
        guard case .permission(let l) = lhs, case .permission(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scheduled, .scheduled): return {
        guard case .scheduled(let l) = lhs, case .scheduled(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pending, .pending): return {
        guard case .pending(let l) = lhs, case .pending(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.triggeredWhileRunning, .triggeredWhileRunning): return {
        guard case .triggeredWhileRunning(let l) = lhs, case .triggeredWhileRunning(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notificationResponse, .notificationResponse): return {
        guard case .notificationResponse(let l) = lhs, case .notificationResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.remoteNotificationRegistration, .remoteNotificationRegistration): return {
        guard case .remoteNotificationRegistration(let l) = lhs, case .remoteNotificationRegistration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct Pending {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var items: [BevyIos_Notifications_AsyncEvent.Pending.PendingNotification] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct PendingNotification {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var identifier: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct Scheduled {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identifier: String = String()

    var success: Bool = false

    var error: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Permission {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var granted: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct NotificationResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identifier: String = String()

    var actionIdentifier: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct NotificationWhileRunning {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identifier: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RemoteNotificationRegistration {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var results: BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.OneOf_Results? = nil

    var failed: BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.Failed {
      get {
        if case .failed(let v)? = results {return v}
        return BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.Failed()
      }
      set {results = .failed(newValue)}
    }

    var token: BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.DeviceToken {
      get {
        if case .token(let v)? = results {return v}
        return BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.DeviceToken()
      }
      set {results = .token(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Results: Equatable {
      case failed(BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.Failed)
      case token(BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.DeviceToken)

    #if !swift(>=4.1)
      static func ==(lhs: BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.OneOf_Results, rhs: BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.OneOf_Results) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.failed, .failed): return {
          guard case .failed(let l) = lhs, case .failed(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.token, .token): return {
          guard case .token(let l) = lhs, case .token(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    struct DeviceToken {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var token: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Failed {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var localizedDescription: String = String()

      var code: Int32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension BevyIos_Notifications_NotificationId: @unchecked Sendable {}
extension BevyIos_Notifications_Request: @unchecked Sendable {}
extension BevyIos_Notifications_Request.OneOf_Calls: @unchecked Sendable {}
extension BevyIos_Notifications_Request.Schedule: @unchecked Sendable {}
extension BevyIos_Notifications_Request.Schedule.Trigger: @unchecked Sendable {}
extension BevyIos_Notifications_Request.Pending: @unchecked Sendable {}
extension BevyIos_Notifications_Request.RemoveAllPending: @unchecked Sendable {}
extension BevyIos_Notifications_Request.RemoveAllDelivered: @unchecked Sendable {}
extension BevyIos_Notifications_Request.RemovePending: @unchecked Sendable {}
extension BevyIos_Notifications_Request.RemoveDelivered: @unchecked Sendable {}
extension BevyIos_Notifications_Request.Permissions: @unchecked Sendable {}
extension BevyIos_Notifications_UserData: @unchecked Sendable {}
extension BevyIos_Notifications_Response: @unchecked Sendable {}
extension BevyIos_Notifications_Response.OneOf_Calls: @unchecked Sendable {}
extension BevyIos_Notifications_Response.Schedule: @unchecked Sendable {}
extension BevyIos_Notifications_Response.Pending: @unchecked Sendable {}
extension BevyIos_Notifications_AsyncEvent: @unchecked Sendable {}
extension BevyIos_Notifications_AsyncEvent.OneOf_Calls: @unchecked Sendable {}
extension BevyIos_Notifications_AsyncEvent.Pending: @unchecked Sendable {}
extension BevyIos_Notifications_AsyncEvent.Pending.PendingNotification: @unchecked Sendable {}
extension BevyIos_Notifications_AsyncEvent.Scheduled: @unchecked Sendable {}
extension BevyIos_Notifications_AsyncEvent.Permission: @unchecked Sendable {}
extension BevyIos_Notifications_AsyncEvent.NotificationResponse: @unchecked Sendable {}
extension BevyIos_Notifications_AsyncEvent.NotificationWhileRunning: @unchecked Sendable {}
extension BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration: @unchecked Sendable {}
extension BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.OneOf_Results: @unchecked Sendable {}
extension BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.DeviceToken: @unchecked Sendable {}
extension BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.Failed: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bevy_ios.notifications"

extension BevyIos_Notifications_NotificationId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotificationId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_NotificationId, rhs: BevyIos_Notifications_NotificationId) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "permissions"),
    2: .same(proto: "schedule"),
    3: .same(proto: "pending"),
    4: .same(proto: "removePending"),
    5: .same(proto: "removeDelivered"),
    6: .same(proto: "removeAllPending"),
    7: .same(proto: "removeAllDelivered"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: BevyIos_Notifications_Request.Permissions?
        var hadOneofValue = false
        if let current = self.calls {
          hadOneofValue = true
          if case .permissions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.calls = .permissions(v)
        }
      }()
      case 2: try {
        var v: BevyIos_Notifications_Request.Schedule?
        var hadOneofValue = false
        if let current = self.calls {
          hadOneofValue = true
          if case .schedule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.calls = .schedule(v)
        }
      }()
      case 3: try {
        var v: BevyIos_Notifications_Request.Pending?
        var hadOneofValue = false
        if let current = self.calls {
          hadOneofValue = true
          if case .pending(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.calls = .pending(v)
        }
      }()
      case 4: try {
        var v: BevyIos_Notifications_Request.RemovePending?
        var hadOneofValue = false
        if let current = self.calls {
          hadOneofValue = true
          if case .removePending(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.calls = .removePending(v)
        }
      }()
      case 5: try {
        var v: BevyIos_Notifications_Request.RemoveDelivered?
        var hadOneofValue = false
        if let current = self.calls {
          hadOneofValue = true
          if case .removeDelivered(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.calls = .removeDelivered(v)
        }
      }()
      case 6: try {
        var v: BevyIos_Notifications_Request.RemoveAllPending?
        var hadOneofValue = false
        if let current = self.calls {
          hadOneofValue = true
          if case .removeAllPending(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.calls = .removeAllPending(v)
        }
      }()
      case 7: try {
        var v: BevyIos_Notifications_Request.RemoveAllDelivered?
        var hadOneofValue = false
        if let current = self.calls {
          hadOneofValue = true
          if case .removeAllDelivered(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.calls = .removeAllDelivered(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.calls {
    case .permissions?: try {
      guard case .permissions(let v)? = self.calls else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .schedule?: try {
      guard case .schedule(let v)? = self.calls else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .pending?: try {
      guard case .pending(let v)? = self.calls else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .removePending?: try {
      guard case .removePending(let v)? = self.calls else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .removeDelivered?: try {
      guard case .removeDelivered(let v)? = self.calls else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .removeAllPending?: try {
      guard case .removeAllPending(let v)? = self.calls else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .removeAllDelivered?: try {
      guard case .removeAllDelivered(let v)? = self.calls else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_Request, rhs: BevyIos_Notifications_Request) -> Bool {
    if lhs.calls != rhs.calls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_Request.Schedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BevyIos_Notifications_Request.protoMessageName + ".Schedule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "body"),
    3: .same(proto: "categoryIdentifier"),
    4: .same(proto: "subtitle"),
    5: .same(proto: "relevanceScore"),
    6: .same(proto: "threadIdentifier"),
    7: .same(proto: "filterCriteria"),
    8: .same(proto: "userData"),
    9: .same(proto: "identifier"),
    10: .same(proto: "badge"),
    11: .same(proto: "trigger"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.body) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.categoryIdentifier) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.subtitle) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.relevanceScore) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.threadIdentifier) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._filterCriteria) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._userData) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._identifier) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self._badge) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._trigger) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularStringField(value: self.body, fieldNumber: 2)
    }
    if !self.categoryIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.categoryIdentifier, fieldNumber: 3)
    }
    if !self.subtitle.isEmpty {
      try visitor.visitSingularStringField(value: self.subtitle, fieldNumber: 4)
    }
    if self.relevanceScore != 0 {
      try visitor.visitSingularDoubleField(value: self.relevanceScore, fieldNumber: 5)
    }
    if !self.threadIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.threadIdentifier, fieldNumber: 6)
    }
    try { if let v = self._filterCriteria {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._userData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._identifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._badge {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._trigger {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_Request.Schedule, rhs: BevyIos_Notifications_Request.Schedule) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.body != rhs.body {return false}
    if lhs.categoryIdentifier != rhs.categoryIdentifier {return false}
    if lhs.subtitle != rhs.subtitle {return false}
    if lhs.relevanceScore != rhs.relevanceScore {return false}
    if lhs.threadIdentifier != rhs.threadIdentifier {return false}
    if lhs._filterCriteria != rhs._filterCriteria {return false}
    if lhs._userData != rhs._userData {return false}
    if lhs._identifier != rhs._identifier {return false}
    if lhs._badge != rhs._badge {return false}
    if lhs._trigger != rhs._trigger {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_Request.Schedule.Trigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BevyIos_Notifications_Request.Schedule.protoMessageName + ".Trigger"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "repeat"),
    2: .same(proto: "seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.`repeat`) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.seconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.`repeat` != false {
      try visitor.visitSingularBoolField(value: self.`repeat`, fieldNumber: 1)
    }
    if self.seconds != 0 {
      try visitor.visitSingularDoubleField(value: self.seconds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_Request.Schedule.Trigger, rhs: BevyIos_Notifications_Request.Schedule.Trigger) -> Bool {
    if lhs.`repeat` != rhs.`repeat` {return false}
    if lhs.seconds != rhs.seconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_Request.Pending: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BevyIos_Notifications_Request.protoMessageName + ".Pending"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_Request.Pending, rhs: BevyIos_Notifications_Request.Pending) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_Request.RemoveAllPending: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BevyIos_Notifications_Request.protoMessageName + ".RemoveAllPending"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_Request.RemoveAllPending, rhs: BevyIos_Notifications_Request.RemoveAllPending) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_Request.RemoveAllDelivered: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BevyIos_Notifications_Request.protoMessageName + ".RemoveAllDelivered"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_Request.RemoveAllDelivered, rhs: BevyIos_Notifications_Request.RemoveAllDelivered) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_Request.RemovePending: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BevyIos_Notifications_Request.protoMessageName + ".RemovePending"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_Request.RemovePending, rhs: BevyIos_Notifications_Request.RemovePending) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_Request.RemoveDelivered: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BevyIos_Notifications_Request.protoMessageName + ".RemoveDelivered"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_Request.RemoveDelivered, rhs: BevyIos_Notifications_Request.RemoveDelivered) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_Request.Permissions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BevyIos_Notifications_Request.protoMessageName + ".Permissions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alert"),
    2: .same(proto: "sound"),
    3: .same(proto: "badge"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.alert) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.sound) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.badge) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alert != false {
      try visitor.visitSingularBoolField(value: self.alert, fieldNumber: 1)
    }
    if self.sound != false {
      try visitor.visitSingularBoolField(value: self.sound, fieldNumber: 2)
    }
    if self.badge != false {
      try visitor.visitSingularBoolField(value: self.badge, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_Request.Permissions, rhs: BevyIos_Notifications_Request.Permissions) -> Bool {
    if lhs.alert != rhs.alert {return false}
    if lhs.sound != rhs.sound {return false}
    if lhs.badge != rhs.badge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_UserData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_UserData, rhs: BevyIos_Notifications_UserData) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "schedule"),
    2: .same(proto: "pending"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: BevyIos_Notifications_Response.Schedule?
        var hadOneofValue = false
        if let current = self.calls {
          hadOneofValue = true
          if case .schedule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.calls = .schedule(v)
        }
      }()
      case 2: try {
        var v: BevyIos_Notifications_Response.Pending?
        var hadOneofValue = false
        if let current = self.calls {
          hadOneofValue = true
          if case .pending(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.calls = .pending(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.calls {
    case .schedule?: try {
      guard case .schedule(let v)? = self.calls else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .pending?: try {
      guard case .pending(let v)? = self.calls else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_Response, rhs: BevyIos_Notifications_Response) -> Bool {
    if lhs.calls != rhs.calls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_Response.Schedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BevyIos_Notifications_Response.protoMessageName + ".Schedule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_Response.Schedule, rhs: BevyIos_Notifications_Response.Schedule) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_Response.Pending: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BevyIos_Notifications_Response.protoMessageName + ".Pending"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_Response.Pending, rhs: BevyIos_Notifications_Response.Pending) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_AsyncEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AsyncEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "permission"),
    2: .same(proto: "scheduled"),
    3: .same(proto: "pending"),
    4: .same(proto: "triggeredWhileRunning"),
    5: .same(proto: "notificationResponse"),
    6: .same(proto: "remoteNotificationRegistration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: BevyIos_Notifications_AsyncEvent.Permission?
        var hadOneofValue = false
        if let current = self.calls {
          hadOneofValue = true
          if case .permission(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.calls = .permission(v)
        }
      }()
      case 2: try {
        var v: BevyIos_Notifications_AsyncEvent.Scheduled?
        var hadOneofValue = false
        if let current = self.calls {
          hadOneofValue = true
          if case .scheduled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.calls = .scheduled(v)
        }
      }()
      case 3: try {
        var v: BevyIos_Notifications_AsyncEvent.Pending?
        var hadOneofValue = false
        if let current = self.calls {
          hadOneofValue = true
          if case .pending(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.calls = .pending(v)
        }
      }()
      case 4: try {
        var v: BevyIos_Notifications_AsyncEvent.NotificationWhileRunning?
        var hadOneofValue = false
        if let current = self.calls {
          hadOneofValue = true
          if case .triggeredWhileRunning(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.calls = .triggeredWhileRunning(v)
        }
      }()
      case 5: try {
        var v: BevyIos_Notifications_AsyncEvent.NotificationResponse?
        var hadOneofValue = false
        if let current = self.calls {
          hadOneofValue = true
          if case .notificationResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.calls = .notificationResponse(v)
        }
      }()
      case 6: try {
        var v: BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration?
        var hadOneofValue = false
        if let current = self.calls {
          hadOneofValue = true
          if case .remoteNotificationRegistration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.calls = .remoteNotificationRegistration(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.calls {
    case .permission?: try {
      guard case .permission(let v)? = self.calls else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .scheduled?: try {
      guard case .scheduled(let v)? = self.calls else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .pending?: try {
      guard case .pending(let v)? = self.calls else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .triggeredWhileRunning?: try {
      guard case .triggeredWhileRunning(let v)? = self.calls else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .notificationResponse?: try {
      guard case .notificationResponse(let v)? = self.calls else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .remoteNotificationRegistration?: try {
      guard case .remoteNotificationRegistration(let v)? = self.calls else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_AsyncEvent, rhs: BevyIos_Notifications_AsyncEvent) -> Bool {
    if lhs.calls != rhs.calls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_AsyncEvent.Pending: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BevyIos_Notifications_AsyncEvent.protoMessageName + ".Pending"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_AsyncEvent.Pending, rhs: BevyIos_Notifications_AsyncEvent.Pending) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_AsyncEvent.Pending.PendingNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BevyIos_Notifications_AsyncEvent.Pending.protoMessageName + ".PendingNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_AsyncEvent.Pending.PendingNotification, rhs: BevyIos_Notifications_AsyncEvent.Pending.PendingNotification) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_AsyncEvent.Scheduled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BevyIos_Notifications_AsyncEvent.protoMessageName + ".Scheduled"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .same(proto: "success"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_AsyncEvent.Scheduled, rhs: BevyIos_Notifications_AsyncEvent.Scheduled) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_AsyncEvent.Permission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BevyIos_Notifications_AsyncEvent.protoMessageName + ".Permission"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "granted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.granted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.granted != false {
      try visitor.visitSingularBoolField(value: self.granted, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_AsyncEvent.Permission, rhs: BevyIos_Notifications_AsyncEvent.Permission) -> Bool {
    if lhs.granted != rhs.granted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_AsyncEvent.NotificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BevyIos_Notifications_AsyncEvent.protoMessageName + ".NotificationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .same(proto: "actionIdentifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.actionIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    if !self.actionIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.actionIdentifier, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_AsyncEvent.NotificationResponse, rhs: BevyIos_Notifications_AsyncEvent.NotificationResponse) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.actionIdentifier != rhs.actionIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_AsyncEvent.NotificationWhileRunning: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BevyIos_Notifications_AsyncEvent.protoMessageName + ".NotificationWhileRunning"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_AsyncEvent.NotificationWhileRunning, rhs: BevyIos_Notifications_AsyncEvent.NotificationWhileRunning) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BevyIos_Notifications_AsyncEvent.protoMessageName + ".RemoteNotificationRegistration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "failed"),
    2: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.Failed?
        var hadOneofValue = false
        if let current = self.results {
          hadOneofValue = true
          if case .failed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.results = .failed(v)
        }
      }()
      case 2: try {
        var v: BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.DeviceToken?
        var hadOneofValue = false
        if let current = self.results {
          hadOneofValue = true
          if case .token(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.results = .token(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.results {
    case .failed?: try {
      guard case .failed(let v)? = self.results else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .token?: try {
      guard case .token(let v)? = self.results else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration, rhs: BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.DeviceToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.protoMessageName + ".DeviceToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.DeviceToken, rhs: BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.DeviceToken) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.Failed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.protoMessageName + ".Failed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "localizedDescription"),
    2: .same(proto: "code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.localizedDescription) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localizedDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.localizedDescription, fieldNumber: 1)
    }
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.Failed, rhs: BevyIos_Notifications_AsyncEvent.RemoteNotificationRegistration.Failed) -> Bool {
    if lhs.localizedDescription != rhs.localizedDescription {return false}
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
